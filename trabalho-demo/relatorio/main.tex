\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}

\usepackage{microtype}
\usepackage[caption=false]{subfig}
\usepackage{bm}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{booktabs,longtable}

\usepackage{algpseudocode}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetArgSty{textnormal}
\DontPrintSemicolon

\sloppy

\title{Metaheurística GRASP com refinamento por busca local para o Flowshop Permutacional}

\author{Alberto F. K. Neto\inst{1}}

\address{Instituto de Informática -- Universidade Federal do Rio Grande do Sul
  (UFRGS)\\
  Caixa Postal 15.064 -- 91.501-970 -- Porto Alegre -- RS -- Brazil
  \email{afkneto@inf.ufrgs.br} 
}

\begin{document} 

\maketitle

\section{Introdução}

Este relatório refere-se ao trabalho de otimização da disciplina de Otimização
Combinatória (INF05010), cursada no período de 2019/1. O texto apresenta o
problema de otimização considerado e introduz um modelo de Programação Linear
Inteira da literatura do problema. Detalhes sobre o desenvolvimento de um método
de solução heurístico baseado em GRASP e Busca Local encontram-se disponíveis
nas seções indicadas, e o desempenho do método proposto é comparado com os
melhores valores de solução atualmente conhecidos para um pequeno conjunto de
instâncias de teste. 

\section{Descrição do problema}

O Problema de Flowshop Permutacional (PFSP) é um tema de pesquisa recorrente
nos estudos da otimização combinatória. O problema considera um conjunto de 
$M$ máquinas e $N$ tarefas, em que todas as tarefas devem ser processadas 
exatamente uma vez em cada uma das máquinas consideradas. Cada tarefa 
$1 \leqslant j \leqslant N$ demora $T_{rj} \geqslant 0$ unidades de tempo para ser 
processada cada máquina $1 \leqslant r \leqslant M$. Busca-se uma ordem de
execução das tarefas que minimize o tempo final de processamento da última 
máquina considerada. Essa ordem de execução é seguida por todas as máquinas.

\cite{tseng2004-flowshop-models} propuseram um modelo de programação linear
inteira mista para o problema. As variáveis binárias $D_{ik} \in \{0,1\}$
assumem o valor $1$ para indicar
se a tarefa $i$ deve ser processada em algum momento anterior ao 
processamento da tarefa $k$, com $1 \leqslant i < k \leqslant N$.
Já as variáveis contínuas $C_{ri} \geqslant 0$ indicam o horizonte de tempo 
de processamento que cada tarefa $ 1 \leqslant i \leqslant N$ em cada
máquina $1 \leqslant r \leqslant M$.
Adicionamente, a variável $C_\mathrm{max} \geqslant 0$ é utilizado no
cálculo do tempo final de processamento da última máquina. 
De posse dessas definições, a seguinte formulação modela o Problema de 
Flowshop permutacional. Note a existência de um parâmetro $P$, que é um 
número suficientemente grande usado como ``big-M'' na modelagem das 
restrições lógicas do modelo.

\clearpage 

\begin{align}
   \text{Minimize } C_\mathrm{max} \label{pfsp:obj}
\end{align}
Sujeito a:
\begin{align}
   & C_{1i} \geqslant T_{1i} & & 1 \leqslant i \leqslant N \label{pfsp:complM0} \\
   & C_{ri} - C_{r-1,i} \geqslant T_{ri} & & 2 \leqslant r \leqslant M, 
      1 \leqslant i \leqslant N \label{pfsp:complM} \\
   & C_{ri} - C_{rk} + PD_{ik} \geqslant T_{ri} & & 1 \leqslant r \leqslant M, 
      1 \leqslant i < k \leqslant N \label{pfsp:jobSeqA}\\
   & C_{ri} - C_{rk} + PD_{ik} \leqslant P - T_{rk} & & 1 \leqslant r \leqslant M, 
      1 \leqslant i < k \leqslant N \label{pfsp:jobSeqB} \\
   & C_\mathrm{max} \geqslant C_{Mi} & & 1 \leqslant i \leqslant N \label{pfsp:makespan} \\
   & C_{ri} \geqslant 0 & & 1 \leqslant r \leqslant M, 1 \leqslant i \leqslant N \label{pfsp:Cdom}\\
   & D_{ik} \in \{0,1\} & & 1 \leqslant i < k \leqslant N \label{pfsp:Ddom}
\end{align}

A função objetivo (\ref{pfsp:obj}) minimiza o tempo de processamento final da
última máquina do problema. As restrições (\ref{pfsp:complM0}) e
(\ref{pfsp:complM}) modelam o tempo final de processamento das tarefas na
primera e demais máquinas, respectivamente. As restrições
(\ref{pfsp:jobSeqA}--\ref{pfsp:jobSeqB}) garantem uma única ordem de execução 
das tarefas em todas as máquinas. A restrição (\ref{pfsp:makespan}) calcula o
tempo final de processamento da última máquina. Por fim, as restrições
(\ref{pfsp:Cdom}--\ref{pfsp:Ddom}) modelam o domínio das variáveis de decisão do
problema.

\section{Método de solução com GRASP e Busca Local}

Tendo em vista a questão da típica baixa eficiência de métodos exatos em
resolver problemas de otimização combinatória discreta, propõe-se o seguinte
método de solução heurístico para resolução do problema. O método de solução é
implementa umaa heurística GRASP para construção de uma soluçãoa inicial
\cite{feo1994-grasp}, seguida de uma fase de intensificação com busca local. 
O pseudocódigo dos algoritmos de construção inicial e de busca local são 
listados em \ref{algo:GRASP} e \ref{algo:LS}. 
Na notação a seguir, uma solução é definida como uma lista com a ordem de
processamento das tarefas, e pode ser parcial ou completa.
Uma visão geral do método de
solução está disponível no algoritmo \ref{algo:full}.

\begin{algorithm}[H]
   \footnotesize
   \SetKwFunction{proc}{GRASP}
   \SetKwProg{myproc}{Procedure}{}{}
   \myproc{\proc{$N$, $M$, $T$, $\alpha$}}{
      $\mathit{pend} \gets$ lista com valores $1, 2, \dots, N$ \;
      $s \gets $ lista vazia; $z \gets 0$ \;
      \While{$\mathit{pend}$ não está vazia}{
         $\mathit{RCL} \gets $ lista vazia \;
         \For{$j \in \mathit{pend}$}{
            $\bar{z}_j \gets$ custo da solução parcial $s$ com adição da tarefa $j$ \; 
            adicione a tupla $(j, \bar{z}_j)$ em $\mathit{RCL}$ \;
         }
         ordene $\mathit{RCL}$ em ordem não crescente de $\bar{z}$ \;
         $\mathit{tam} \gets$ tamanho da lista $\mathit{RCL}$ \;
         $\mathit{tp} \gets$ escolhe aleatoriamente um índice 
            de $[1, \max\{1, \alpha \cdot \mathit{tam}\} ]$ \;
         atualize a solução $s$ e custo $z$ com os dados da tupla $\mathit{RCL}_\mathit{tp}$ \;
         remova a tarefa referente a $\mathit{tp}$ de $\mathit{pend}$ \;
      }
   }
   \Return{$s$}
   \caption{Construção de solução inicial com GRASP.}
   \label{algo:GRASP}
\end{algorithm}

O algoritmo GRASP inicial com uma solução vazia, de custo 0, e incrementalmente
adiciona tarefas na ordem de processamento das máquinas. Inicialmente, todas as
tarefas são marcadas como pendentes (lista $\mathit{pend}$). A cada iteração do 
laço principal
(linhas 4--13), calcula-se o custo de inserção de cada tarefa pendente
na solução parcial $s$. Esses valores de custo são adicionados à
lista $\mathit{RCL}$ de tarefas candidatas a entrar na solução. Faz-se a
ordenação dessa lista em ordem não crescente de custo de solução,
e escolhe-se aleatoriamente uma das $\alpha$\% tarefas iniciais da lista de
candidatos. Essa tarefa entra na solução parcial $s$, e o custo $z$ é
atualizado de acordo. Finalmente, a tarefa é removida da lista de pendentes e
a próxima iteração inicia. Essa implementação de GRASP faz a seleção com
$\alpha$ pelos índices da lista de candidatos.

\begin{algorithm}[H]
   \footnotesize
   \SetKwFunction{proc}{Swap2LS}
   \SetKwProg{myproc}{Procedure}{}{}
   \myproc{\proc{$s^*$, numVezes}}{
      $z^* \gets$ custo da solução atual\;
      \For {$i \gets 1$ até $numVezes$} {
         selecione tarefas $j_1 \neq j_2$ aleatoriamente, com distribuição uniforme \;
         $\bar{s} \gets$ troque a ordem de processamento de $j_1 \leftrightarrow j_2$ em $s^*$ \;
         $\bar{z} \gets$ avalie o custo da solução $\bar{s}$ \;
         \If {$\bar{z} < z^*$} {
            $s^* \gets \bar{s}$ \;
            $z^* \gets \bar{z}$ \;
         }
      }
   }
   \Return $s*$
   \caption{Algoritmo de Busca Local iterada com trocas aleatória.}
   \label{algo:LS}
\end{algorithm}

Após a construção de uma solução inicial com GRASP, inicia-se a fase de
melhoramento da solução com o algoritmo de busca local iterado \ref{algo:LS}.
A busca local faz diversas tentativas de troca da ordem de processamento de
duas tarefas em posições distintas, e sempre aceita a troca na ordem das
tarefas caso seja vantajosa (estratégia de ``primeira melhora''). De posse de
ambos os algoritmos, é possível definir o método de solução completo como em
\ref{algo:full}.

\begin{algorithm}[H]
   \footnotesize
   \SetKwFunction{proc}{GRASP\_LS}
   \SetKwProg{myproc}{Procedure}{}{}
   \myproc{\proc{$N$, $M$, $T$, $\alpha$}}{
      $s \gets$ \texttt{GRASP}($N$, $M$, $T$, $\alpha$) \;
      \For{$\mathit{iter} \gets 1$ até $\textit{MAX\_ITER}$ } {
         \texttt{Swap2LS}($s$, $\lceil N/100 \rceil$) \;
         \texttt{Swap2LS}($s$, $\lceil \mathit{iter}/1000 \rceil$) \;
         \texttt{Swap2LS}($s$, \texttt{randomInt}(1,N)) \;
      }
   }
   \Return $s$
   \caption{Algoritmo completo da heurística GRASP com Busca Local.}
   \label{algo:full}
\end{algorithm}

Como consideração final, todas as seleções aleatórias se deram
por distribuição uniforme. Utilizou-se cada uma das replicações 
$n=1, \dots, 10$ da heurística como semente do gerador de números
pseudoaleatórios.

\section{Resultados computacionais}

Os testes computacionais da heurística e da formulação matemática foram
conduzidos nas instâncias de teste indicadas na definição do trabalho da
disciplinas. Utilizou-se um computador Intel 3612QM @ 2.10GHz, dispondo-se de
8 GB de memória principal. A heurística foi implementada em Python 
3.7.4, e o modelo foi resolvido por meio do GLPK 4.65. O ambiente de testes foi
o Arch Linux de 64 bits, com kernel padrão 5.3.8.


\begin{table}[ht]
   \begin{tabular}{lrrrr}
      \toprule
      Instância & BKS & Valor relaxação & Obj. solução inteira & GAP$_\mathrm{BKS}$ (\%) \\
      \midrule
      VFR10\_15\_1 & 1307 & 880.0 & 1307 & \phantom{0}0.0\\
      VFR10\_10\_3 & 1592 & 687.0 & 1873 & 56.9\\
      VFR\_20\_20\_1 & 2270 & 1391.0 & 2573 & 42.6\\
      VFR60\_5\_10 & 3663 & 382.0 & 3878 & 89.3\\
      VFR100\_60\_1 & 9395  &  TL & -- & $\infty$\\
      VFR500\_40\_1 & 28548 &  TL & -- & $\infty$\\
      VFR500\_60\_3 & 31125 &  TL & -- & $\infty$\\
      VFR600\_20\_1 & 31433 &  TL & -- & $\infty$\\
      VFR700\_20\_10 & 36417 & TL & -- & $\infty$\\ 
      \bottomrule
   \end{tabular}
\end{table}

\section{Conclusões}

% \begin{figure}
%    \centering
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR10_15_1.pdf}
%    }
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR20_10_3.pdf}
%    }\\
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR20_20_1.pdf}
%    }
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR60_5_10.pdf}
%    }\\
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR100_60_1.pdf}
%    }
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR100_60_1.pdf}
%    }
%    \caption{Boxplot relacionando valor médio da função objetivo para as diversas 
%       instâncias de testes, com vários valores \bm{$\alpha$} e 10 replicações
%       por caso de teste.}
% \end{figure}
% 
% \begin{figure}
%    \ContinuedFloat
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR500_40_1.pdf}
%    }
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR500_60_3.pdf}
%    }\\
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR600_20_1.pdf}
%    }
%    \subfloat[][]{
%       \includegraphics[width=0.48\textwidth]{../resultados/boxplot-VFR700_20_10.pdf}
%    }
%    \caption{Boxplot relacionando valor médio da função objetivo para as diversas 
%       instâncias de testes, com vários valores \bm{$\alpha$} e 10 replicações
%       por caso de teste. Continuação da figura anterior.}
% \end{figure}

\bibliographystyle{sbc}
\bibliography{referencias}

\appendix

\section*{Apêndice A -- Média dos resultados computacionais para diversos
\protect{$\alpha$}}

\tiny
\input{table-medias.tex}
\normalsize

\end{document}
